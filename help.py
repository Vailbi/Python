# a = input()  # по умолчанию присваивается str
# print(a)  # 123 → '123'
#
# a = int(input())  # оборачивание int() если нужно числовое значение
# print(a)  # 123 → 123
#
# a, b, c = input().split()  # множественное присваивание str с пробелом в качестве разделителя
# # (в .split() можно указать любой разделитель, отсутствие аргумента в .split() означает использование пробела в качестве разделителя))
# print(b)  # scissors paper stone → paper
#
# a, b, c = map(int,input().split())  # множественное присваивание int с пробелом в качестве разделителя (в .split()
# # можно указать любой разделитель, отсутствие аргумента в .split() означает использование пробела в качестве разделителя)
# print(b)  # 1 2 3 → 2
#
# a = list(input())  # создание списка из каждого символа введенной строки (пробел при вводе тоже воспринимается как символ)
# print(a)  # letters → ['l', 'e', 't', 't', 'e', 'r', 's']
#
# a = list(map(int, input()))  # создание списка из каждой цифры введенного числа (пробелы при вводе вызовут ошибку)
# print(a)  # 123456 → [1, 2, 3, 4, 5, 6]
#
# a = list(input().split())  # создание списка из отдельных строк (в .split() можно указать любой разделитель,
# # отсутствие аргумента в .split() означает использование пробела в качестве разделителя)
# print(a)  # letters words → ['letters', 'words']
#
# a = input().split()  # тоже самое что и a = list(input().split())
# print(a)  # letters words → ['letters', 'words']
#
# a = list(map(int,input().split()))  # создание списка из отдельных чисел (в .split() можно указать любой разделитель,
# # отсутствие аргумента в .split() означает использование пробела в качестве разделителя)
# print(a)  # 123 456 → [123, 456]

arr = input()
newarr = arr.replace(arr[:2], '12')
print(newarr)

# menu = data.write('Фамилия Имя Отчество телефон')
# data.write('\n')

# from time import time
#
# beg = time()
# for i in range(200000):
#
#     lst = '''Как видно из примера, присвоение по новому ключу расширяет словарь,
#     присвоение по существующему ключу перезаписывает его, а попытка извлечения
#     несуществующего ключа порождает исключение. Для избежания исключения есть
#     специальный метод (см. ниже), или можно перехватывать исключение. Что же
#     можно еще делать со словарями? Да то же самое, что и с другими объектами:
#     встроенные функции, ключевые слова (например, циклы for и while), а также
#     специальные методы словарей. Как видно из примера, присвоение по новому ключу расширяет словарь,
#     присвоение по существующему ключу перезаписывает его, а попытка извлечения
#     несуществующего ключа порождает исключение. Для избежания исключения есть
#     специальный метод (см. ниже), или можно перехватывать исключение. Что же
#     можно еще делать со словарями? Да то же самое, что и с другими объектами:
#     встроенные функции, ключевые слова (например, циклы for и while), а также
#     специальные методы словарей.
#     '''.lower().split()
#     test = {x: lst.count(x) for x in lst}
#
# end = time()
# print(end - beg)
#
#
# beg1 = time()
# for x in range(200000):
#
#     lst = '''Как видно из примера, присвоение по новому ключу расширяет словарь,
#     присвоение по существующему ключу перезаписывает его, а попытка извлечения
#     несуществующего ключа порождает исключение. Для избежания исключения есть
#     специальный метод (см. ниже), или можно перехватывать исключение. Что же
#     можно еще делать со словарями? Да то же самое, что и с другими объектами:
#     встроенные функции, ключевые слова (например, циклы for и while), а также
#     специальные методы словарей. Как видно из примера, присвоение по новому ключу расширяет словарь,
#     присвоение по существующему ключу перезаписывает его, а попытка извлечения
#     несуществующего ключа порождает исключение. Для избежания исключения есть
#     специальный метод (см. ниже), или можно перехватывать исключение. Что же
#     можно еще делать со словарями? Да то же самое, что и с другими объектами:
#     встроенные функции, ключевые слова (например, циклы for и while), а также
#     специальные методы словарей.
#     '''.lower().split()
#     test = {x: lst.count(x) for x in set(lst)}
#
# end1 = time()
# print(end1 - beg1)